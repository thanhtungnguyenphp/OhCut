"""Integration tests using real video files generated by FFmpeg.

These tests verify end-to-end behavior of video and audio operations with
actual media. They require FFmpeg to be installed and available in PATH.
"""

import os
import math
import subprocess
from pathlib import Path

import pytest

from core import video_ops, audio_ops
from utils.file_utils import get_video_info
from core.ffmpeg_runner import check_ffmpeg_installed


pytestmark = [pytest.mark.integration]


def require_ffmpeg():
    if not check_ffmpeg_installed():
        pytest.skip("FFmpeg not installed; skipping integration tests")


def _gen_color_video(path: Path, color: str = "red", duration: int = 2, size: str = "640x360"):
    cmd = [
        "ffmpeg",
        "-f",
        "lavfi",
        "-i",
        f"color=c={color}:size={size}:duration={duration}:rate=30",
        "-f",
        "lavfi",
        "-i",
        f"anullsrc=channel_layout=stereo:sample_rate=44100:duration={duration}",
        "-c:v",
        "libx264",
        "-preset",
        "ultrafast",
        "-crf",
        "28",
        "-pix_fmt",
        "yuv420p",
        "-c:a",
        "aac",
        "-b:a",
        "128k",
        "-y",
        str(path),
    ]
    subprocess.run(cmd, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)


def _gen_testsrc_video(path: Path, duration: int = 10, size: str = "1280x720"):
    cmd = [
        "ffmpeg",
        "-f",
        "lavfi",
        "-i",
        f"testsrc=duration={duration}:size={size}:rate=30",
        "-f",
        "lavfi",
        "-i",
        f"sine=frequency=1000:duration={duration}",
        "-c:v",
        "libx264",
        "-preset",
        "ultrafast",
        "-crf",
        "28",
        "-pix_fmt",
        "yuv420p",
        "-c:a",
        "aac",
        "-b:a",
        "128k",
        "-y",
        str(path),
    ]
    subprocess.run(cmd, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)


@pytest.fixture()
def tmpmedia(tmp_path: Path):
    """Create a temporary media directory and return path helper."""
    media = tmp_path / "media"
    media.mkdir()
    return media


def test_concat_copy_mode(tmpmedia: Path):
    require_ffmpeg()
    # Generate 3 color clips of 2s each
    r = tmpmedia / "red.mp4"
    g = tmpmedia / "green.mp4"
    b = tmpmedia / "blue.mp4"
    _gen_color_video(r, "red", duration=2)
    _gen_color_video(g, "green", duration=2)
    _gen_color_video(b, "blue", duration=2)

    out = tmpmedia / "concat.mp4"
    video_ops.concat_videos([str(r), str(g), str(b)], str(out), copy_codec=True)

    assert out.exists()
    info = get_video_info(str(out))
    # Expect ~6s total (allow tolerance +/- 0.6s)
    assert math.isclose(info["duration"], 6.0, rel_tol=0.0, abs_tol=0.6)


def test_cut_by_duration_segments(tmpmedia: Path):
    require_ffmpeg()
    src = tmpmedia / "src.mp4"
    _gen_testsrc_video(src, duration=10, size="640x360")

    outdir = tmpmedia / "clips"
    outdir.mkdir()

    segments = video_ops.cut_by_duration(str(src), str(outdir), segment_duration=3, prefix="clip")

    # Expect at least 2 segments (FFmpeg segment muxer may vary)
    assert len(segments) >= 2
    for p in segments:
        assert Path(p).exists()


def test_cut_by_timestamps_basic(tmpmedia: Path):
    require_ffmpeg()
    src = tmpmedia / "src2.mp4"
    _gen_testsrc_video(src, duration=8, size="640x360")

    outdir = tmpmedia / "tsclips"
    outdir.mkdir()

    ts = [(0, 3), (3, 5), (5, 8)]
    segments = video_ops.cut_by_timestamps(str(src), str(outdir), ts, prefix="ts")

    assert len(segments) == 3
    for p in segments:
        assert Path(p).exists()


def test_audio_extract_and_replace(tmpmedia: Path):
    require_ffmpeg()
    src = tmpmedia / "withaudio.mp4"
    _gen_testsrc_video(src, duration=5, size="640x360")

    audio = tmpmedia / "audio.m4a"
    audio_ops.extract_audio(str(src), str(audio), codec="aac", bitrate="128k")
    assert audio.exists() and audio.stat().st_size > 0

    out = tmpmedia / "replaced.mp4"
    audio_ops.replace_audio(str(src), str(audio), str(out), copy_codecs=True)
    assert out.exists() and out.stat().st_size > 0


def test_profile_reencode_web_720p(tmpmedia: Path):
    require_ffmpeg()
    src = tmpmedia / "src3.mp4"
    _gen_testsrc_video(src, duration=6, size="1280x720")

    outdir = tmpmedia / "reencode"
    outdir.mkdir()

    # Use web_720p profile (exists in profiles.yaml)
    segments = video_ops.cut_by_duration(
        str(src), str(outdir), segment_duration=6, copy_codec=False, profile_name="web_720p"
    )

    assert len(segments) >= 1
    info = get_video_info(segments[0])
    # Codec should be h264 (web_720p uses libx264)
    assert "h264" in info.get("codec", "").lower()
